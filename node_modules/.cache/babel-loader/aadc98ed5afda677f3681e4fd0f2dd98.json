{"ast":null,"code":"import { optimizedCompoundCondition as e, FieldCondition as t, CompoundCondition as r, ITSELF as n, NULL_CONDITION as o, buildAnd as a, ObjectQueryParser as i } from \"@ucast/core\";\nexport { defaultInstructionParsers as defaultParsers } from \"@ucast/core\";\n\nfunction f(e, t) {\n  if (!Array.isArray(t)) throw new Error('\"' + e.name + '\" expects value to be an array');\n}\n\nfunction u(e, t) {\n  if (f(e, t), !t.length) throw new Error('\"' + e.name + '\" expects to have at least one element in array');\n}\n\nvar c = function (e) {\n  return function (t, r) {\n    if (typeof r !== e) throw new Error('\"' + t.name + '\" expects value to be a \"' + e + '\"');\n  };\n},\n    p = {\n  type: \"compound\",\n  validate: u,\n  parse: function (t, r, n) {\n    var o = n.parse,\n        a = r.map(function (e) {\n      return o(e);\n    });\n    return e(t.name, a);\n  }\n},\n    s = p,\n    l = {\n  type: \"compound\",\n  validate: u\n},\n    d = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!(t && (t instanceof RegExp || t.constructor === Object))) throw new Error('\"' + e.name + '\" expects to receive either regular expression or object of field operators');\n  },\n  parse: function (e, n, o) {\n    var a = n instanceof RegExp ? new t(\"regex\", o.field, n) : o.parse(n, o);\n    return new r(e.name, [a]);\n  }\n},\n    v = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!t || t.constructor !== Object) throw new Error('\"' + e.name + '\" expects to receive an object with nested query or field level operators');\n  },\n  parse: function (e, r, o) {\n    var a = o.parse,\n        i = o.field,\n        f = (0, o.hasOperators)(r) ? a(r, {\n      field: n\n    }) : a(r);\n    return new t(e.name, i, f);\n  }\n},\n    w = {\n  type: \"field\",\n  validate: c(\"number\")\n},\n    y = {\n  type: \"field\",\n  validate: f\n},\n    $ = y,\n    x = y,\n    h = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!Array.isArray(t) || 2 !== t.length) throw new Error('\"' + e.name + '\" expects an array with 2 numeric elements');\n  }\n},\n    m = {\n  type: \"field\",\n  validate: c(\"boolean\")\n},\n    g = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!(\"string\" == typeof t || \"number\" == typeof t || t instanceof Date)) throw new Error('\"' + e.name + '\" expects value to be comparable (i.e., string, number or date)');\n  }\n},\n    b = g,\n    E = b,\n    j = b,\n    O = {\n  type: \"field\"\n},\n    R = O,\n    _ = {\n  type: \"field\",\n  validate: function (e, t) {\n    if (!(t instanceof RegExp) && \"string\" != typeof t) throw new Error('\"' + e.name + '\" expects value to be a regular expression or a string that represents regular expression');\n  },\n  parse: function (e, r, n) {\n    var o = \"string\" == typeof r ? new RegExp(r, n.query.$options || \"\") : r;\n    return new t(e.name, n.field, o);\n  }\n},\n    q = {\n  type: \"field\",\n  parse: function () {\n    return o;\n  }\n},\n    A = {\n  type: \"document\",\n  validate: c(\"function\")\n},\n    N = Object.freeze({\n  __proto__: null,\n  $and: p,\n  $or: s,\n  $nor: l,\n  $not: d,\n  $elemMatch: v,\n  $size: w,\n  $in: y,\n  $nin: $,\n  $all: x,\n  $mod: h,\n  $exists: m,\n  $gte: g,\n  $gt: b,\n  $lt: E,\n  $lte: j,\n  $eq: O,\n  $ne: R,\n  $regex: _,\n  $options: q,\n  $where: A\n});\n\nvar P = function (e) {\n  var t, r;\n\n  function n(t) {\n    return e.call(this, t, {\n      defaultOperatorName: \"$eq\",\n      operatorToConditionName: function (e) {\n        return e.slice(1);\n      }\n    }) || this;\n  }\n\n  return r = e, (t = n).prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r, n.prototype.parse = function (t, r) {\n    return r && r.field ? a(this.parseFieldOperators(r.field, t)) : e.prototype.parse.call(this, t);\n  }, n;\n}(i),\n    z = N;\n\nexport { x as $all, p as $and, v as $elemMatch, O as $eq, m as $exists, b as $gt, g as $gte, y as $in, E as $lt, j as $lte, h as $mod, R as $ne, $ as $nin, l as $nor, d as $not, q as $options, s as $or, _ as $regex, w as $size, A as $where, P as MongoQueryParser, z as allParsingInstructions };","map":{"version":3,"sources":["../../src/instructions.ts","../../src/MongoQueryParser.ts","../../src/index.ts"],"names":["ensureIsArray","instruction","value","Array","isArray","Error","name","ensureIsNonEmptyArray","length","Date","ensureIs","type","$and","validate","parse","queries","conditions","map","query","optimizedCompoundCondition","$or","$nor","$not","RegExp","constructor","Object","context","condition","FieldCondition","field","CompoundCondition","$elemMatch","hasOperators","ITSELF","$size","$in","$nin","$all","$mod","$exists","$gte","$gt","$lt","$lte","$eq","$ne","$regex","rawValue","$options","NULL_CONDITION","$where","MongoQueryParser","ObjectQueryParser","instructions","_ObjectQueryParser","defaultOperatorName","operatorToConditionName","slice","options","and","this","parseFieldOperators","allParsingInstructions"],"mappings":"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","sourcesContent":["import {\n  CompoundCondition,\n  FieldCondition,\n  NamedInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n  DocumentInstruction,\n  Comparable,\n  ITSELF,\n  NULL_CONDITION,\n  FieldParsingContext,\n  optimizedCompoundCondition,\n  ObjectQueryFieldParsingContext,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nfunction ensureIsArray(instruction: NamedInstruction, value: unknown) {\n  if (!Array.isArray(value)) {\n    throw new Error(`\"${instruction.name}\" expects value to be an array`);\n  }\n}\n\nfunction ensureIsNonEmptyArray(instruction: NamedInstruction, value: unknown[]) {\n  ensureIsArray(instruction, value);\n\n  if (!value.length) {\n    throw new Error(`\"${instruction.name}\" expects to have at least one element in array`);\n  }\n}\n\nfunction ensureIsComparable(instruction: NamedInstruction, value: string | number | Date) {\n  const isComparable = typeof value === 'string' || typeof value === 'number' || value instanceof Date;\n\n  if (!isComparable) {\n    throw new Error(`\"${instruction.name}\" expects value to be comparable (i.e., string, number or date)`);\n  }\n}\n\nconst ensureIs = (type: string) => (instruction: NamedInstruction, value: unknown) => {\n  if (typeof value !== type) { // eslint-disable-line valid-typeof\n    throw new Error(`\"${instruction.name}\" expects value to be a \"${type}\"`);\n  }\n};\n\nexport const $and: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n  parse(instruction, queries, { parse }) {\n    const conditions = queries.map(query => parse(query));\n    return optimizedCompoundCondition(instruction.name, conditions);\n  }\n};\nexport const $or = $and;\nexport const $nor: CompoundInstruction<MongoQuery<any>[]> = {\n  type: 'compound',\n  validate: ensureIsNonEmptyArray,\n};\n\nexport const $not: FieldInstruction<MongoQuery<any> | RegExp> = {\n  type: 'field',\n  validate(instruction, value) {\n    const isValid = value && (value instanceof RegExp || value.constructor === Object);\n\n    if (!isValid) {\n      throw new Error(`\"${instruction.name}\" expects to receive either regular expression or object of field operators`);\n    }\n  },\n  parse(instruction, value, context) {\n    const condition = value instanceof RegExp\n      ? new FieldCondition('regex' as typeof instruction.name, context.field, value)\n      : context.parse(value, context);\n\n    return new CompoundCondition(instruction.name, [condition]);\n  },\n};\nexport const $elemMatch: FieldInstruction<MongoQuery<any>, ObjectQueryFieldParsingContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!value || value.constructor !== Object) {\n      throw new Error(`\"${instruction.name}\" expects to receive an object with nested query or field level operators`);\n    }\n  },\n  parse(instruction, value, { parse, field, hasOperators }) {\n    const condition = hasOperators(value) ? parse(value, { field: ITSELF }) : parse(value);\n    return new FieldCondition(instruction.name, field, condition);\n  }\n};\n\nexport const $size: FieldInstruction<number> = {\n  type: 'field',\n  validate: ensureIs('number')\n};\nexport const $in: FieldInstruction<unknown[]> = {\n  type: 'field',\n  validate: ensureIsArray,\n};\nexport const $nin = $in;\nexport const $all = $in;\nexport const $mod: FieldInstruction<[number, number]> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!Array.isArray(value) || value.length !== 2) {\n      throw new Error(`\"${instruction.name}\" expects an array with 2 numeric elements`);\n    }\n  }\n};\n\nexport const $exists: FieldInstruction<boolean> = {\n  type: 'field',\n  validate: ensureIs('boolean'),\n};\n\nexport const $gte: FieldInstruction<Comparable> = {\n  type: 'field',\n  validate: ensureIsComparable\n};\nexport const $gt = $gte;\nexport const $lt = $gt;\nexport const $lte = $gt;\n\nexport const $eq: FieldInstruction = {\n  type: 'field',\n};\nexport const $ne = $eq;\n\nexport interface RegExpFieldContext extends FieldParsingContext {\n  query: {\n    $options?: string\n  }\n}\n\nexport const $regex: FieldInstruction<string | RegExp, RegExpFieldContext> = {\n  type: 'field',\n  validate(instruction, value) {\n    if (!(value instanceof RegExp) && typeof value !== 'string') {\n      throw new Error(`\"${instruction.name}\" expects value to be a regular expression or a string that represents regular expression`);\n    }\n  },\n  parse(instruction, rawValue, context) {\n    const value = typeof rawValue === 'string'\n      ? new RegExp(rawValue, context.query.$options || '')\n      : rawValue;\n    return new FieldCondition(instruction.name, context.field, value);\n  }\n};\nexport const $options: FieldInstruction = {\n  type: 'field',\n  parse: () => NULL_CONDITION,\n};\n\nexport const $where: DocumentInstruction<() => boolean> = {\n  type: 'document',\n  validate: ensureIs('function'),\n};\n","import {\n  Condition,\n  buildAnd as and,\n  ParsingInstruction,\n  ObjectQueryParser,\n  FieldQueryOperators,\n} from '@ucast/core';\nimport { MongoQuery } from './types';\n\nexport interface ParseOptions {\n  field: string\n}\n\nexport class MongoQueryParser extends ObjectQueryParser<MongoQuery<any>> {\n  constructor(instructions: Record<string, ParsingInstruction>) {\n    super(instructions, {\n      defaultOperatorName: '$eq',\n      operatorToConditionName: name => name.slice(1),\n    });\n  }\n\n  parse<Q extends MongoQuery<any>, FQ extends FieldQueryOperators<Q> = FieldQueryOperators<Q>>(\n    query: Q | FQ,\n    options?: ParseOptions\n  ): Condition {\n    if (options && options.field) {\n      return and(this.parseFieldOperators(options.field, query as FQ));\n    }\n\n    return super.parse(query);\n  }\n}\n","import * as instructions from './instructions';\n\nexport const allParsingInstructions = instructions;\nexport * from './instructions';\nexport * from './MongoQueryParser';\nexport * from './types';\nexport { defaultInstructionParsers as defaultParsers } from '@ucast/core';\n"]},"metadata":{},"sourceType":"module"}