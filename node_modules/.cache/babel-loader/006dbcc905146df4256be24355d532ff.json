{"ast":null,"code":"import { createTranslatorFactory as r, ITSELF as t } from \"@ucast/core\";\nexport * from \"@ucast/core\";\nimport { MongoQueryParser as o, allParsingInstructions as n, defaultParsers as e } from \"@ucast/mongo\";\nexport * from \"@ucast/mongo\";\nimport { createJsInterpreter as f, allInterpreters as i, compare as u } from \"@ucast/js\";\nexport * from \"@ucast/js\";\n\nfunction c() {\n  return (c = Object.assign || function (r) {\n    for (var t = 1; t < arguments.length; t++) {\n      var o = arguments[t];\n\n      for (var n in o) Object.prototype.hasOwnProperty.call(o, n) && (r[n] = o[n]);\n    }\n\n    return r;\n  }).apply(this, arguments);\n}\n\nfunction a(r) {\n  return r instanceof Date ? r.getTime() : r && \"function\" == typeof r.toJSON ? r.toJSON() : r;\n}\n\nvar m = function (r, t) {\n  return u(a(r), a(t));\n};\n\nfunction p(n, e, i) {\n  var u = new o(n),\n      a = f(e, c({\n    compare: m\n  }, i));\n\n  if (i && i.forPrimitives) {\n    var p = {\n      field: t\n    },\n        s = u.parse;\n    u.setParse(function (r) {\n      return s(r, p);\n    });\n  }\n\n  return r(u.parse, a);\n}\n\nvar s = p(n, i),\n    v = p([\"$and\", \"$or\"].reduce(function (r, t) {\n  return r[t] = c({}, r[t], {\n    type: \"field\"\n  }), r;\n}, c({}, n, {\n  $nor: c({}, n.$nor, {\n    type: \"field\",\n    parse: e.compound\n  })\n})), i, {\n  forPrimitives: !0\n}),\n    d = s;\nexport { p as createFactory, d as filter, s as guard, v as squire };","map":{"version":3,"sources":["../../src/factory.ts"],"names":["toPrimitive","value","Date","getTime","toJSON","comparePrimitives","a","b","compare","createFactory","instructions","interpreters","options","parser","MongoQueryParser","interpret","createJsInterpreter","forPrimitives","params","field","ITSELF","parse","setParse","query","createTranslatorFactory","guard","allParsingInstructions","allInterpreters","reduce","name","type","$nor","defaultParsers","compound","squire","filter"],"mappings":";;;;;;;;;;;;;;;;;AAyBA;;AAAA,SAASA,CAAT,CAAqBC,CAArB,EAAqBA;AAAAA,SACfA,CAAAA,YAAiBC,IAAjBD,GACKA,CAAAA,CAAME,OAANF,EADLA,GAIAA,CAAAA,IAAgD,cAAA,OAA/BA,CAAAA,CAAoBG,MAArCH,GACMA,CAAAA,CAAoBG,MAApBH,EADNA,GAIGA,CATYA;AAYrB;;AAAA,IAAMI,CAAAA,GAAoC,UAACC,CAAD,EAAIC,CAAJ,EAAIA;AAAAA,SAAMC,CAAAA,CAAQR,CAAAA,CAAYM,CAAZN,CAARQ,EAAwBR,CAAAA,CAAYO,CAAZP,CAAxBQ,CAAND;AAA0CA,CAAxF;;AAyBO,SAASE,CAAT,CAILC,CAJK,EAIYC,CAJZ,EAI6BC,CAJ7B,EAI6BA;AAAAA,MAC5BC,CAAAA,GAAS,IAAIC,CAAJ,CAAqBJ,CAArB,CADmBE;AAAAA,MAE5BG,CAAAA,GAAYC,CAAAA,CAAoBL,CAApBK,EAAoBL,CAAAA,CAAAA;AACpCH,IAAAA,OAAAA,EAASH;AAD2BM,GAAAA,EAEjCC,CAFiCD,CAApBK,CAFgBJ;;AAI7BA,MAGDA,CAAAA,IAAWA,CAAAA,CAAQK,aAHlBL,EAGiC;AAAA,QAC9BM,CAAAA,GAAS;AAAEC,MAAAA,KAAAA,EAAOC;AAAT,KADqB;AAAA,QAE9BC,CAAAA,GAAQR,CAAAA,CAAOQ,KAFe;AAGpCR,IAAAA,CAAAA,CAAOS,QAAPT,CAAgB,UAAA,CAAA,EAAA;AAAA,aAASQ,CAAAA,CAAME,CAANF,EAAaH,CAAbG,CAAT;AAAsBH,KAAtCL;AAAsCK;;AAAAA,SAGjCM,CAAAA,CAAwBX,CAAAA,CAAOQ,KAA/BG,EAAsCT,CAAtCS,CAHiCN;AAGKH;;AAAAA,IAGlCU,CAAAA,GAAQhB,CAAAA,CAAciB,CAAdjB,EAAsCkB,CAAtClB,CAH0BM;AAAAA,IAkBlCmB,CAAAA,GAASzB,CAAAA,CAbI,CAAC,MAAD,EAAS,KAAT,EACgCmB,MADhC,CACuC,UAAClB,CAAD,EAAemB,CAAf,EAAeA;AAAAA,SAC9EnB,CAAAA,CAAamB,CAAbnB,CAAAA,GAAamB,CAAAA,CAAAA,EAAAA,EAAanB,CAAAA,CAAamB,CAAbnB,CAAbmB,EAA0BA;AAAOC,IAAAA,IAAAA,EAAM;AAAbD,GAA1BA,CAAbnB,EACOA,CAFuEmB;AAEvEnB,CAHiB,EAGjBA,CAAAA,CAAAA,EAAAA,EAEJgB,CAFIhB,EAEJgB;AACHK,EAAAA,IAAAA,EAAAA,CAAAA,CAAAA,EAAAA,EACKL,CAAAA,CAAuBK,IAD5BA,EAC4BA;AAC1BD,IAAAA,IAAAA,EAAM,OADoBC;AAE1BV,IAAAA,KAAAA,EAAOW,CAAAA,CAAeC;AAFIF,GAD5BA;AADGL,CAFIhB,CAHiB,CAaJD,EAA+CkB,CAA/ClB,EAAgE;AACpFQ,EAAAA,aAAAA,EAAAA,CAAe;AADqE,CAAhER,CAlByBM;AAAAA,IAqBlCoB,CAAAA,GAASV,CArByBV;AAqBzBU,SAAAA,CAAAA,IAAAA,aAAAA,EAAAA,CAAAA,IAAAA,MAAAA,EAAAA,CAAAA,IAAAA,KAAAA,EAAAA,CAAAA,IAAAA,MAAAA","sourcesContent":["import { createTranslatorFactory, ParsingInstruction, Condition, ITSELF } from '@ucast/core';\nimport {\n  MongoQuery,\n  MongoQueryParser,\n  MongoQueryFieldOperators,\n  allParsingInstructions,\n  defaultParsers\n} from '@ucast/mongo';\nimport {\n  createJsInterpreter,\n  allInterpreters,\n  JsInterpreter,\n  JsInterpretationOptions,\n  compare\n} from '@ucast/js';\n\ntype ThingFilter<T> = {\n  (object: T): boolean\n  ast: Condition\n};\n\ninterface HasToJSON {\n  toJSON(): unknown\n}\n\nfunction toPrimitive(value: unknown) {\n  if (value instanceof Date) {\n    return value.getTime();\n  }\n\n  if (value && typeof (value as HasToJSON).toJSON === 'function') {\n    return (value as HasToJSON).toJSON();\n  }\n\n  return value;\n}\n\nconst comparePrimitives: typeof compare = (a, b) => compare(toPrimitive(a), toPrimitive(b));\n\nexport interface FactoryOptions extends JsInterpretationOptions {\n  forPrimitives: boolean\n}\n\nexport type Filter = <\n  T = Record<string, unknown>,\n  Q extends MongoQuery<T> = MongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\nexport type PrimitiveMongoQuery<T> = MongoQueryFieldOperators<T> & Partial<{\n  $and: MongoQueryFieldOperators<T>[],\n  $or: MongoQueryFieldOperators<T>[],\n  $nor: MongoQueryFieldOperators<T>[]\n}>;\nexport type PrimitiveFilter = <\n  T,\n  Q extends PrimitiveMongoQuery<T> = PrimitiveMongoQuery<T>\n>(query: Q) => ThingFilter<T>;\n\ntype FilterType<T extends { forPrimitives?: true }> = T['forPrimitives'] extends true\n  ? PrimitiveFilter\n  : Filter;\n\nexport function createFactory<\n  T extends Record<string, ParsingInstruction<any, any>>,\n  I extends Record<string, JsInterpreter<any>>,\n  P extends { forPrimitives?: true }\n>(instructions: T, interpreters: I, options?: Partial<FactoryOptions> & P): FilterType<P> {\n  const parser = new MongoQueryParser(instructions);\n  const interpret = createJsInterpreter(interpreters, {\n    compare: comparePrimitives,\n    ...options\n  });\n\n  if (options && options.forPrimitives) {\n    const params = { field: ITSELF };\n    const parse = parser.parse;\n    parser.setParse(query => parse(query, params));\n  }\n\n  return createTranslatorFactory(parser.parse, interpret) as any;\n}\n\nexport const guard = createFactory(allParsingInstructions, allInterpreters);\n\nconst compoundOperators = ['$and', '$or'] as const;\nconst allPrimitiveParsingInstructions = compoundOperators.reduce((instructions, name) => {\n  instructions[name] = { ...instructions[name], type: 'field' } as any;\n  return instructions;\n}, {\n  ...allParsingInstructions,\n  $nor: {\n    ...allParsingInstructions.$nor,\n    type: 'field',\n    parse: defaultParsers.compound\n  }\n});\n\nexport const squire = createFactory(allPrimitiveParsingInstructions, allInterpreters, {\n  forPrimitives: true\n});\nexport const filter = guard; // TODO: remove in next major version\n"]},"metadata":{},"sourceType":"module"}