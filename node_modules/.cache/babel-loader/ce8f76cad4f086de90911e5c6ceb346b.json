{"ast":null,"code":"function t(t, r) {\n  for (var n = 0; n < r.length; n++) {\n    var i = r[n];\n    i.enumerable = i.enumerable || !1, i.configurable = !0, \"value\" in i && (i.writable = !0), Object.defineProperty(t, i.key, i);\n  }\n}\n\nfunction r() {\n  return (r = Object.assign || function (t) {\n    for (var r = 1; r < arguments.length; r++) {\n      var n = arguments[r];\n\n      for (var i in n) Object.prototype.hasOwnProperty.call(n, i) && (t[i] = n[i]);\n    }\n\n    return t;\n  }).apply(this, arguments);\n}\n\nfunction n(t, r) {\n  t.prototype = Object.create(r.prototype), t.prototype.constructor = t, t.__proto__ = r;\n}\n\nvar i = function () {\n  function r(t, r) {\n    this.operator = t, this.value = r, Object.defineProperty(this, \"t\", {\n      writable: !0\n    });\n  }\n\n  var n, i, e;\n  return r.prototype.addNote = function (t) {\n    this.t = this.t || [], this.t.push(t);\n  }, n = r, (i = [{\n    key: \"notes\",\n    get: function () {\n      return this.t;\n    }\n  }]) && t(n.prototype, i), e && t(n, e), r;\n}(),\n    e = function (t) {\n  function r() {\n    return t.apply(this, arguments) || this;\n  }\n\n  return n(r, t), r;\n}(i),\n    o = function (t) {\n  function r(r, n) {\n    if (!Array.isArray(n)) throw new Error('\"' + r + '\" operator expects to receive an array of conditions');\n    return t.call(this, r, n) || this;\n  }\n\n  return n(r, t), r;\n}(e),\n    u = \"__itself__\",\n    f = function (t) {\n  function r(r, n, i) {\n    var e;\n    return (e = t.call(this, r, i) || this).field = n, e;\n  }\n\n  return n(r, t), r;\n}(i),\n    a = new e(\"__null__\", null),\n    c = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nfunction s(t, r) {\n  return r instanceof o && r.operator === t;\n}\n\nfunction h(t, r) {\n  return 1 === r.length ? r[0] : new o(t, function t(r, n, i) {\n    for (var e = i || [], o = 0, u = n.length; o < u; o++) {\n      var f = n[o];\n      s(r, f) ? t(r, f.value, e) : e.push(f);\n    }\n\n    return e;\n  }(t, r));\n}\n\nvar v = function (t) {\n  return t;\n},\n    d = function () {\n  return Object.create(null);\n},\n    l = Object.defineProperty(d(), \"__@type@__\", {\n  value: \"ignore value\"\n});\n\nfunction p(t, r, n) {\n  if (void 0 === n && (n = !1), !t || t && t.constructor !== Object) return !1;\n\n  for (var i in t) {\n    if (c(t, i) && c(r, i) && (!n || t[i] !== l)) return !0;\n  }\n\n  return !1;\n}\n\nfunction w(t) {\n  var r = [];\n\n  for (var n in t) c(t, n) && t[n] !== l && r.push(n);\n\n  return r;\n}\n\nfunction b(t, r) {\n  r !== a && t.push(r);\n}\n\nvar y = function (t) {\n  return h(\"and\", t);\n},\n    O = function (t) {\n  return h(\"or\", t);\n},\n    j = {\n  compound: function (t, r, n) {\n    var i = (Array.isArray(r) ? r : [r]).map(function (t) {\n      return n.parse(t);\n    });\n    return new o(t.name, i);\n  },\n  field: function (t, r, n) {\n    return new f(t.name, n.field, r);\n  },\n  document: function (t, r) {\n    return new e(t.name, r);\n  }\n},\n    _ = function () {\n  function t(t, n) {\n    var i = this;\n    void 0 === n && (n = d()), this.i = void 0, this.o = void 0, this.u = void 0, this.s = void 0, this.h = void 0, this.parse = this.parse.bind(this), this.s = {\n      operatorToConditionName: n.operatorToConditionName || v,\n      defaultOperatorName: n.defaultOperatorName || \"eq\",\n      mergeFinalConditions: n.mergeFinalConditions || y\n    }, this.i = Object.keys(t).reduce(function (n, e) {\n      return n[e] = r({\n        name: i.s.operatorToConditionName(e)\n      }, t[e]), n;\n    }, {}), this.o = r({}, n.fieldContext, {\n      field: \"\",\n      query: {},\n      parse: this.parse,\n      hasOperators: function (t) {\n        return p(t, i.i, n.useIgnoreValue);\n      }\n    }), this.u = r({}, n.documentContext, {\n      parse: this.parse,\n      query: {}\n    }), this.h = n.useIgnoreValue ? w : Object.keys;\n  }\n\n  var n = t.prototype;\n  return n.setParse = function (t) {\n    this.parse = t, this.o.parse = t, this.u.parse = t;\n  }, n.parseField = function (t, r, n, i) {\n    var e = this.i[r];\n    if (!e) throw new Error('Unsupported operator \"' + r + '\"');\n    if (\"field\" !== e.type) throw new Error(\"Unexpected \" + e.type + ' operator \"' + r + '\" at field level');\n    return this.o.field = t, this.o.query = i, this.parseInstruction(e, n, this.o);\n  }, n.parseInstruction = function (t, r, n) {\n    return \"function\" == typeof t.validate && t.validate(t, r), (t.parse || j[t.type])(t, r, n);\n  }, n.parseFieldOperators = function (t, r) {\n    for (var n = [], i = this.h(r), e = 0, o = i.length; e < o; e++) {\n      var u = i[e];\n      if (!this.i[u]) throw new Error('Field query for \"' + t + '\" may contain only operators or a plain object as a value');\n      b(n, this.parseField(t, u, r[u], r));\n    }\n\n    return n;\n  }, n.parse = function (t) {\n    var r = [],\n        n = this.h(t);\n    this.u.query = t;\n\n    for (var i = 0, e = n.length; i < e; i++) {\n      var o = n[i],\n          u = t[o],\n          f = this.i[o];\n\n      if (f) {\n        if (\"document\" !== f.type && \"compound\" !== f.type) throw new Error('Cannot use parsing instruction for operator \"' + o + '\" in \"document\" context as it is supposed to be used in  \"' + f.type + '\" context');\n        b(r, this.parseInstruction(f, u, this.u));\n      } else this.o.hasOperators(u) ? r.push.apply(r, this.parseFieldOperators(o, u)) : b(r, this.parseField(o, this.s.defaultOperatorName, u, t));\n    }\n\n    return this.s.mergeFinalConditions(r);\n  }, t;\n}();\n\nfunction m(t, r) {\n  var n = t[r];\n  if (\"function\" != typeof n) throw new Error('Unable to interpret \"' + r + '\" condition. Did you forget to register interpreter for it?');\n  return n;\n}\n\nfunction g(t) {\n  return t.operator;\n}\n\nfunction E(t, n) {\n  var i,\n      e = n,\n      o = e && e.getInterpreterName || g;\n\n  switch (e ? e.numberOfArguments : 0) {\n    case 1:\n      i = function (r) {\n        var n = o(r, e);\n        return m(t, n)(r, u);\n      };\n\n      break;\n\n    case 3:\n      i = function (r, n, i) {\n        var f = o(r, e);\n        return m(t, f)(r, n, i, u);\n      };\n\n      break;\n\n    default:\n      i = function (r, n) {\n        var i = o(r, e);\n        return m(t, i)(r, n, u);\n      };\n\n  }\n\n  var u = r({}, e, {\n    interpret: i\n  });\n  return u.interpret;\n}\n\nfunction x(t, r) {\n  return function (n) {\n    for (var i = arguments.length, e = new Array(i > 1 ? i - 1 : 0), o = 1; o < i; o++) e[o - 1] = arguments[o];\n\n    var u = t.apply(void 0, [n].concat(e)),\n        f = r.bind(null, u);\n    return f.ast = u, f;\n  };\n}\n\nvar q = _.prototype.parseInstruction;\nexport { o as CompoundCondition, i as Condition, e as DocumentCondition, f as FieldCondition, u as ITSELF, a as NULL_CONDITION, _ as ObjectQueryParser, y as buildAnd, O as buildOr, E as createInterpreter, x as createTranslatorFactory, j as defaultInstructionParsers, p as hasOperators, v as identity, l as ignoreValue, s as isCompound, d as object, h as optimizedCompoundCondition, q as parseInstruction };","map":{"version":3,"sources":["../../src/Condition.ts","../../src/utils.ts","../../src/builder.ts","../../src/parsers/defaultInstructionParsers.ts","../../src/parsers/ObjectQueryParser.ts","../../src/interpreter.ts","../../src/translator.ts","../../src/index.ts"],"names":["Condition","operator","value","Object","defineProperty","this","writable","_notes","addNote","note","push","DocumentCondition","CompoundCondition","conditions","Array","isArray","Error","_DocumentCondition","ITSELF","FieldCondition","field","NULL_CONDITION","hasOwnProperty","prototype","call","bind","isCompound","condition","flattenConditions","aggregatedResult","flatConditions","i","length","currentNode","optimizedCompoundCondition","identity","x","object","create","ignoreValue","hasOperators","instructions","skipIgnore","constructor","prop","objectKeysSkipIgnore","anyObject","keys","key","pushIfNonNullCondition","buildAnd","buildOr","defaultInstructionParsers","compound","instruction","context","map","parse","query","name","document","ObjectQueryParser","_instructions","_fieldInstructionContext","_documentInstructionContext","_options","_objectKeys","options","operatorToConditionName","defaultOperatorName","mergeFinalConditions","reduce","all","_this","fieldContext","useIgnoreValue","documentContext","setParse","parseField","parentQuery","type","parseInstruction","validate","parseFieldOperators","op","getInterpreter","interpreters","interpret","defaultInterpreterName","createInterpreter","rawOptions","getInterpreterName","numberOfArguments","interpreterName","defaultContext","params","createTranslatorFactory","args","ast","translate"],"mappings":"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","sourcesContent":["export interface Note<T> {\n  type: string\n  message?: string\n  originalValue?: T\n}\n\nexport abstract class Condition<T = unknown> {\n  private _notes!: Note<T>[];\n\n  constructor(\n    public readonly operator: string,\n    public readonly value: T\n  ) {\n    Object.defineProperty(this, '_notes', {\n      writable: true\n    });\n  }\n\n  get notes(): ReadonlyArray<Note<T>> | undefined {\n    return this._notes;\n  }\n\n  addNote(note: Note<T>) {\n    this._notes = this._notes || [];\n    this._notes.push(note);\n  }\n}\n\nexport class DocumentCondition<T> extends Condition<T> {\n}\n\nexport class CompoundCondition<T extends Condition = Condition> extends DocumentCondition<T[]> {\n  constructor(operator: string, conditions: T[]) {\n    if (!Array.isArray(conditions)) {\n      throw new Error(`\"${operator}\" operator expects to receive an array of conditions`);\n    }\n\n    super(operator, conditions);\n  }\n}\n\nexport const ITSELF = '__itself__';\nexport class FieldCondition<T = unknown> extends Condition<T> {\n  public readonly field!: string | typeof ITSELF;\n\n  constructor(operator: string, field: string | typeof ITSELF, value: T) {\n    super(operator, value);\n    this.field = field;\n  }\n}\n\nexport const NULL_CONDITION = new DocumentCondition('__null__', null);\nexport type ConditionValue<T> = T extends Condition<infer V> ? V : unknown;\n","import { Condition, CompoundCondition, NULL_CONDITION } from './Condition';\n\nconst hasOwnProperty = Object.prototype.hasOwnProperty.call.bind(Object.prototype.hasOwnProperty);\n\nexport function isCompound(operator: string, condition: Condition): condition is CompoundCondition {\n  return condition instanceof CompoundCondition && condition.operator === operator;\n}\n\nfunction flattenConditions<T extends Condition>(\n  operator: string,\n  conditions: T[],\n  aggregatedResult?: T[]\n) {\n  const flatConditions: T[] = aggregatedResult || [];\n\n  for (let i = 0, length = conditions.length; i < length; i++) {\n    const currentNode = conditions[i];\n\n    if (isCompound(operator, currentNode)) {\n      flattenConditions(operator, currentNode.value as T[], flatConditions);\n    } else {\n      flatConditions.push(currentNode);\n    }\n  }\n\n  return flatConditions;\n}\n\nexport function optimizedCompoundCondition<T extends Condition>(operator: string, conditions: T[]) {\n  if (conditions.length === 1) {\n    return conditions[0];\n  }\n\n  return new CompoundCondition(operator, flattenConditions(operator, conditions));\n}\n\nexport const identity = <T>(x: T) => x;\nexport const object = () => Object.create(null);\n\nexport const ignoreValue: IgnoreValue = Object.defineProperty(object(), '__@type@__', {\n  value: 'ignore value'\n});\nexport interface IgnoreValue {\n  readonly ['__@type@__']: 'ignore value'\n}\n\nexport function hasOperators<T>(\n  value: any,\n  instructions: Record<string, unknown>,\n  skipIgnore = false,\n): value is T {\n  if (!value || value && value.constructor !== Object) {\n    return false;\n  }\n\n  for (const prop in value) { // eslint-disable-line no-restricted-syntax, guard-for-in\n    const hasProp = hasOwnProperty(value, prop) && hasOwnProperty(instructions, prop);\n    if (hasProp && (!skipIgnore || value[prop] !== ignoreValue)) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nexport function objectKeysSkipIgnore(anyObject: Record<string, unknown>) {\n  const keys: string[] = [];\n  for (const key in anyObject) { // eslint-disable-line no-restricted-syntax\n    if (hasOwnProperty(anyObject, key) && anyObject[key] !== ignoreValue) {\n      keys.push(key);\n    }\n  }\n\n  return keys;\n}\n\nexport function pushIfNonNullCondition(conditions: Condition[], condition: Condition) {\n  if (condition !== NULL_CONDITION) {\n    conditions.push(condition);\n  }\n}\n","import { Condition } from './Condition';\nimport { optimizedCompoundCondition } from './utils';\n\nexport const buildAnd = (conditions: Condition[]) => optimizedCompoundCondition('and', conditions);\nexport const buildOr = (conditions: Condition[]) => optimizedCompoundCondition('or', conditions);\n","import {\n  FieldCondition,\n  CompoundCondition,\n  DocumentCondition,\n} from '../Condition';\nimport {\n  DocumentInstruction,\n  CompoundInstruction,\n  FieldInstruction,\n} from '../types';\n\ninterface DefaultParsers {\n  compound: Exclude<CompoundInstruction['parse'], undefined>,\n  field: Exclude<FieldInstruction['parse'], undefined>,\n  document: Exclude<DocumentInstruction['parse'], undefined>\n}\n\nexport const defaultInstructionParsers: DefaultParsers = {\n  compound(instruction, value, context) {\n    const queries = Array.isArray(value) ? value : [value];\n    const conditions = queries.map(query => context.parse(query));\n    return new CompoundCondition(instruction.name, conditions);\n  },\n  field(instruction, value, context) {\n    return new FieldCondition(instruction.name, context.field, value);\n  },\n  document(instruction, value) {\n    return new DocumentCondition(instruction.name, value);\n  }\n};\n","import { Condition } from '../Condition';\nimport {\n  NamedInstruction,\n  ParsingInstruction,\n  FieldParsingContext,\n  ParsingContext,\n} from '../types';\nimport { buildAnd } from '../builder';\nimport { defaultInstructionParsers } from './defaultInstructionParsers';\nimport {\n  identity,\n  hasOperators,\n  object,\n  pushIfNonNullCondition,\n  objectKeysSkipIgnore,\n} from '../utils';\n\nexport type FieldQueryOperators<T extends {}> = {\n  [K in keyof T]: T[K] extends {} ? T[K] : never\n}[keyof T];\n\ntype ParsingInstructions = Record<string, NamedInstruction>;\n\nexport interface QueryOptions {\n  operatorToConditionName?(name: string): string\n  defaultOperatorName?: string\n  fieldContext?: Record<string, unknown>\n  documentContext?: Record<string, unknown>\n  useIgnoreValue?: boolean\n  mergeFinalConditions?(conditions: Condition[]): Condition\n}\n\nexport type ObjectQueryFieldParsingContext = ParsingContext<FieldParsingContext & {\n  query: {},\n  hasOperators<T>(value: unknown): value is T\n}>;\n\nexport class ObjectQueryParser<\n  T extends Record<any, any>,\n  U extends FieldQueryOperators<T> = FieldQueryOperators<T>\n> {\n  private readonly _instructions: ParsingInstructions;\n  private _fieldInstructionContext: ObjectQueryFieldParsingContext;\n  private _documentInstructionContext: ParsingContext<{ query: {} }>;\n  private readonly _options: Required<\n  Pick<QueryOptions, 'operatorToConditionName' | 'defaultOperatorName' | 'mergeFinalConditions'>\n  >;\n\n  private readonly _objectKeys: typeof Object.keys;\n\n  constructor(instructions: Record<string, ParsingInstruction>, options: QueryOptions = object()) {\n    this.parse = this.parse.bind(this);\n    this._options = {\n      operatorToConditionName: options.operatorToConditionName || identity,\n      defaultOperatorName: options.defaultOperatorName || 'eq',\n      mergeFinalConditions: options.mergeFinalConditions || buildAnd,\n    };\n    this._instructions = Object.keys(instructions).reduce((all, name) => {\n      all[name] = { name: this._options.operatorToConditionName(name), ...instructions[name] };\n      return all;\n    }, {} as ParsingInstructions);\n    this._fieldInstructionContext = {\n      ...options.fieldContext,\n      field: '',\n      query: {},\n      parse: this.parse,\n      hasOperators: <T>(value: unknown): value is T => hasOperators(\n        value,\n        this._instructions,\n        options.useIgnoreValue\n      ),\n    };\n    this._documentInstructionContext = {\n      ...options.documentContext,\n      parse: this.parse,\n      query: {}\n    };\n    this._objectKeys = options.useIgnoreValue ? objectKeysSkipIgnore : Object.keys;\n  }\n\n  setParse(parse: this['parse']) {\n    this.parse = parse;\n    this._fieldInstructionContext.parse = parse;\n    this._documentInstructionContext.parse = parse;\n  }\n\n  protected parseField(field: string, operator: string, value: unknown, parentQuery: {}) {\n    const instruction = this._instructions[operator];\n\n    if (!instruction) {\n      throw new Error(`Unsupported operator \"${operator}\"`);\n    }\n\n    if (instruction.type !== 'field') {\n      throw new Error(`Unexpected ${instruction.type} operator \"${operator}\" at field level`);\n    }\n\n    this._fieldInstructionContext.field = field;\n    this._fieldInstructionContext.query = parentQuery;\n\n    return this.parseInstruction(instruction, value, this._fieldInstructionContext);\n  }\n\n  // eslint-disable-next-line class-methods-use-this\n  protected parseInstruction(\n    instruction: NamedInstruction,\n    value: unknown,\n    context: ParsingContext<{}>\n  ) {\n    if (typeof instruction.validate === 'function') {\n      instruction.validate(instruction, value);\n    }\n\n    const parse: typeof instruction.parse = instruction.parse\n      || defaultInstructionParsers[instruction.type as keyof typeof defaultInstructionParsers];\n    return parse(instruction, value, context);\n  }\n\n  protected parseFieldOperators(field: string, value: U) {\n    const conditions: Condition[] = [];\n    const keys = this._objectKeys(value);\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const op = keys[i];\n      const instruction = this._instructions[op];\n\n      if (!instruction) {\n        throw new Error(`Field query for \"${field}\" may contain only operators or a plain object as a value`);\n      }\n\n      const condition = this.parseField(field, op, value[op as keyof U], value);\n      pushIfNonNullCondition(conditions, condition);\n    }\n\n    return conditions;\n  }\n\n  parse<Q extends T>(query: Q): Condition {\n    const conditions = [];\n    const keys = this._objectKeys(query);\n\n    this._documentInstructionContext.query = query;\n\n    for (let i = 0, length = keys.length; i < length; i++) {\n      const key = keys[i];\n      const value = query[key];\n      const instruction = this._instructions[key];\n\n      if (instruction) {\n        if (instruction.type !== 'document' && instruction.type !== 'compound') {\n          throw new Error(`Cannot use parsing instruction for operator \"${key}\" in \"document\" context as it is supposed to be used in  \"${instruction.type}\" context`);\n        }\n\n        pushIfNonNullCondition(\n          conditions,\n          this.parseInstruction(instruction, value, this._documentInstructionContext)\n        );\n      } else if (this._fieldInstructionContext.hasOperators<U>(value)) {\n        conditions.push(...this.parseFieldOperators(key, value));\n      } else {\n        pushIfNonNullCondition(\n          conditions,\n          this.parseField(key, this._options.defaultOperatorName, value, query)\n        );\n      }\n    }\n\n    return this._options.mergeFinalConditions(conditions);\n  }\n}\n","import { Condition } from './Condition';\n\ntype ArgsExceptLast<F extends (...args: any[]) => any> =\n  F extends (a: any, c: any) => any\n    ? Parameters<(condition: Condition) => 0>\n    : F extends (a: any, b: any, c: any) => any\n      ? Parameters<(condition: Condition, value: Parameters<F>[1]) => 0>\n      : Parameters<(\n        condition: Condition,\n        value: Parameters<F>[1],\n        options: Parameters<F>[2],\n        ...args: unknown[]\n      ) => 0>;\n\nexport type Interpreter<T extends Condition, R> = (condition: T, ...args: any[]) => R;\nexport type AnyInterpreter = Interpreter<any, any>;\nexport interface InterpretationContext<T extends AnyInterpreter> {\n  interpret(...args: ArgsExceptLast<T>): ReturnType<T>;\n}\n\nfunction getInterpreter<T extends Record<string, AnyInterpreter>>(\n  interpreters: T,\n  operator: keyof T\n) {\n  const interpret = interpreters[operator];\n\n  if (typeof interpret !== 'function') {\n    throw new Error(`Unable to interpret \"${operator}\" condition. Did you forget to register interpreter for it?`);\n  }\n\n  return interpret;\n}\n\nexport interface InterpreterOptions {\n  numberOfArguments?: 1 | 2 | 3\n  getInterpreterName?(condition: Condition, context: this): string\n}\n\nfunction defaultInterpreterName(condition: Condition) {\n  return condition.operator;\n}\n\nexport function createInterpreter<T extends AnyInterpreter, U extends {} = {}>(\n  interpreters: Record<string, T>,\n  rawOptions?: U\n) {\n  const options = rawOptions as U & InterpreterOptions;\n  const getInterpreterName = options && options.getInterpreterName || defaultInterpreterName;\n  let interpret;\n\n  switch (options ? options.numberOfArguments : 0) {\n    case 1:\n      interpret = ((condition) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    case 3:\n      interpret = ((condition, value, params) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, params, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n    default:\n      interpret = ((condition, value) => {\n        const interpreterName = getInterpreterName(condition, options);\n        const interpretOperator = getInterpreter(interpreters, interpreterName);\n        return interpretOperator(condition, value, defaultContext); // eslint-disable-line @typescript-eslint/no-use-before-define\n      }) as InterpretationContext<T>['interpret'];\n      break;\n  }\n\n  const defaultContext = {\n    ...options,\n    interpret,\n  } as InterpretationContext<T> & U;\n\n  return defaultContext.interpret;\n}\n","import { Condition } from './Condition';\nimport { Parse } from './types';\nimport { AnyInterpreter } from './interpreter';\n\ntype Bound<T> = T extends (first: Condition, ...args: infer A) => any\n  ? { (...args: A): ReturnType<T>, ast: Condition }\n  : never;\n\nexport function createTranslatorFactory<Lang, Interpreter extends AnyInterpreter>(\n  parse: Parse<Lang>,\n  interpret: Interpreter\n) {\n  return (query: Lang, ...args: unknown[]): Bound<Interpreter> => {\n    const ast = parse(query, ...args);\n    const translate = (interpret as any).bind(null, ast);\n    translate.ast = ast;\n    return translate;\n  };\n}\n","import { ObjectQueryParser } from './parsers/ObjectQueryParser';\n\nexport * from './Condition';\nexport * from './types';\nexport * from './interpreter';\nexport * from './translator';\nexport * from './builder';\nexport {\n  isCompound,\n  hasOperators,\n  identity,\n  object,\n  optimizedCompoundCondition,\n  ignoreValue,\n} from './utils';\nexport type {\n  IgnoreValue\n} from './utils';\nexport * from './parsers/ObjectQueryParser';\nexport * from './parsers/defaultInstructionParsers';\n/**\n * @deprecated use `ObjectQueryParser#parseInstruction` instead\n * TODO(major): remove\n */\nexport const parseInstruction = (ObjectQueryParser.prototype as any).parseInstruction;\n"]},"metadata":{},"sourceType":"module"}